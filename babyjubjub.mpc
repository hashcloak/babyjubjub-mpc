import sys
sys.path.append("../MP-SPDZ")
from Compiler.types import sint

program.use_edabit(True)
program.set_bit_length(32)

# Constants
a_pub = sint(168700)
d_pub = sint(168696)
q_pub = sint(21888242871839275222246405745257275088548364400416034343698204186575808495617)

class BabyJubJubPoint:
    def __init__(self, x1, y1, n=0):
        self.x = sint(x1)
        self.y = sint(y1)
        self.n_players = n

    @property
    def generator(self):
        x = 995203441582195749578291179787384436505546430278305826713579947235728471134
        y = 5472060717959818805561601436314318772137091100104008585924551046643952123905
        return BabyJubJubPoint(x, y, self.n_players)

    def __neg__(self):
        return BabyJubJubPoint(-self.x, self.y)

    def __add__(self, Q):
        # TODO : Short circuiting for when either point is 0
        x3 = (self.x * Q.y + self.y * Q.x).int_div(sint(1) + (d_pub * self.x * self.y * Q.x * Q.y))
        y3 = (self.y*Q.y - a_pub*self.x*Q.x).int_div(1 - (d_pub *self.x * self.y * Q.x * Q.y))
        return BabyJubJubPoint(x3, y3, self.n_players)

    def double(self):
        # TODO : Short circuiting for when the point is 0
        return self + self

    def ec_if_else(self, Q, b):
        x_r = b * (self.x - Q.x) + Q.x
        y_r = b * (self.y - Q.y) + Q.y
        return BabyJubJubPoint(x_r, y_r, self.n_players)

    @staticmethod
    def _get_point_from(player):
        x, y = sint.get_input_from(player, size=2)
        return BabyJubJubPoint(x, y)

    """
    Returns a random BabyJubJubPoint
    Assumes that the format of each players input is already in point format i.e. (x, y)
    """
    @staticmethod
    def rand(n_players):
        R = BabyJubJubPoint._get_point_from(0)
        for i in range(1, n_players):
            R = R + BabyJubJubPoint._get_point_from(i)

        return R   

    @staticmethod
    def rand_pair(n_players):
        R = BabyJubJubPoint._get_point_from(0)
        aR = BabyJubJubPoint._get_point_from(0)
        for i in range(1, n_players):
            R = R + BabyJubJubPoint._get_point_from(i)
            aR = R + BabyJubJubPoint._get_point_from(i)

        return (R, aR)

    def add_uf(self, *points):
        n_points = len(points)
        S = [BabyJubJubPoint.rand(n_points) for i in range(n_points)]
        T = [points[0]]
        for i in range(1, n_points):
            t = -S[i] + points[i]
            T.append(t)
        U_shares = []
        for i in range(n_points):
            U_shares.append(T[i] + S[i])

        Ux = sum([u.x for u in U_shares])
        Uy = sum([u.y for u in U_shares])
        U = BabyJubJubPoint(Ux, Uy)
        R = U + -S[n_points - 1]
        return R

    def __mul__(self, s):
        pass

a = 168700
d = 168696
q = 21888242871839275222246405745257275088548364400416034343698204186575808495617

# Check point (0, 0)
x1 = sint(0)
y1 = sint(0)
p1 = BabyJubJubPoint(x1, y1, 3)

x2 = sint(0)
y2 = sint(0)
p2 = BabyJubJubPoint(x2, y2, 3)

p3 = p1 + p2

expected_x3 = (x1*y2+y1*x2).int_div(1+d*x1*x2*y1*y2)
expected_y3 = (y1*y2-a*x1*x2).int_div(1-d*x1*x2*y1*y2)

print_ln('expected (%s, %s), got (%s, %s)', expected_x3.reveal(), expected_y3.reveal(), p3.x.reveal(), p3.y.reveal())

# Check non-zero point
x1 = sint(17777552123799933955779906779655732241715742912184938656739573121738514868268)
y1 = sint(2626589144620713026669568689430873010625803728049924121243784502389097019475)
p1 = BabyJubJubPoint(x1, y1, 3)

x2 = sint(0)
y2 = sint(1)
p2 = BabyJubJubPoint(x2, y2, 3)

p3 = p1 + p2

expected_x3 = (x1*y2+y1*x2).int_div(1+d*x1*x2*y1*y2)
expected_y3 = (y1*y2-a*x1*x2).int_div(1-d*x1*x2*y1*y2)

print_ln('expected (%s, %s), got (%s, %s)', expected_x3.reveal(), expected_y3.reveal(), p3.x.reveal(), p3.y.reveal())

# Check doubling
p3 = p1.double()

expected_x3 = (x1*y1+y1*x1).int_div(1+d*x1*x1*y1*y1)
expected_y3 = (y1*y1-a*x1*x1).int_div(1-d*x1*x1*y1*y1)

print_ln('expected (%s, %s), got (%s, %s)', expected_x3.reveal(), expected_y3.reveal(), p3.x.reveal(), p3.y.reveal())

# Check conditional
p_r0 = p3.ec_if_else(p2, 1)
print_ln('expected (%s, %s), got (%s, %s)', p3.x.reveal(), p3.y.reveal(), p_r0.x.reveal(), p_r0.y.reveal())

p_r1 = p3.ec_if_else(p2, 0)
print_ln('expected (%s, %s), got (%s, %s)', p2.x.reveal(), p2.y.reveal(), p_r1.x.reveal(), p_r1.y.reveal())

# Check random point generation
#new_p = BabyJubJubPoint.rand(3)
#print_ln('random curve point: (%s, %s)', new_p.x.reveal(), new_p.y.reveal())

# Check pair random point generation
#rand_pair1, rand_pair2 = BabyJubJubPoint.rand_pair(3)
#print_ln('R: (%s, %s), \naR: (%s, %s)', rand_pair1.x.reveal(), rand_pair1.y.reveal(), rand_pair2.x.reveal(), rand_pair2.y.reveal())

# Check add_uf
new_uf_p = p1.add_uf(p2, p3)
print_ln('(%s, %s)', new_uf_p.x.reveal(), new_uf_p.y.reveal())